#!/usr/bin/env node
/**
 * Design Token Generator
 *
 * Automatically generates CSS custom properties from TypeScript design tokens.
 * This ensures a single source of truth and prevents drift between TS and CSS.
 *
 * Best Practices (2025):
 * - Single source of truth (tokens.ts)
 * - Automated CSS generation (this script)
 * - Type safety via TypeScript
 * - No manual CSS duplication
 *
 * Usage: node scripts/generate-tokens.js
 */

const fs = require('fs');
const path = require('path');

const tokensSourcePath = path.join(__dirname, '../src/design/tokens.ts');
const outputPath = path.join(__dirname, '../src/css/_tokens.css');

// Check if source tokens exist
if (!fs.existsSync(tokensSourcePath)) {
  console.error('❌ Error: Design tokens not found at src/design/tokens.ts');
  process.exit(1);
}

/**
 * Parse TypeScript tokens file to extract color values
 * This approach doesn't require TypeScript compilation
 */
function parseTokens(content) {
  const tokens = {
    COLORS: {},
    ALPHA: {},
    TYPOGRAPHY: { fontFamily: {} },
    SIZES: {},
    LAYOUT: { container: {} }
  };

  // Extract COLORS
  const colorsMatch = content.match(/export const COLORS = \{([\s\S]*?)\} as const;/);
  if (colorsMatch) {
    const colorsBlock = colorsMatch[1];

    // Parse each color category
    const categories = ['ink', 'paper', 'accent', 'warm', 'hairline'];
    categories.forEach(category => {
      const regex = new RegExp(`${category}:\\s*\\{([^}]+)\\}`, 's');
      const match = colorsBlock.match(regex);
      if (match) {
        tokens.COLORS[category] = {};
        const props = match[1].matchAll(/(\w+):\s*['"]([^'"]+)['"]/g);
        for (const [, key, value] of props) {
          tokens.COLORS[category][key] = value;
        }
      }
    });
  }

  // Extract ALPHA (transparency variants)
  const alphaMatch = content.match(/export const ALPHA = \{([\s\S]*?)\} as const;/);
  if (alphaMatch) {
    const alphaBlock = alphaMatch[1];

    // Parse paper with nested structure (special case)
    const paperRegex = /paper:\s*\{([\s\S]*?)\n  \},/;
    const paperMatch = alphaBlock.match(paperRegex);
    if (paperMatch) {
      tokens.ALPHA.paper = {};
      // Match each subcategory (white, default, etc.)
      const subCatRegex = /(\w+):\s*\{([\s\S]*?)\n    \},?/g;
      let subMatch;
      while ((subMatch = subCatRegex.exec(paperMatch[1])) !== null) {
        const subKey = subMatch[1];
        const subContent = subMatch[2];
        tokens.ALPHA.paper[subKey] = {};
        const props = subContent.matchAll(/(\d+):\s*['"]([^'"]+)['"]/g);
        for (const [, key, value] of props) {
          tokens.ALPHA.paper[subKey][key] = value;
        }
      }
    }

    // Parse flat structures (accent, warm, white)
    // Use more specific regex to avoid matching nested categories
    const accentRegex = /accent:\s*\{([\s\S]*?)\n  \},/;
    const warmRegex = /warm:\s*\{([\s\S]*?)\n  \},/;
    // Match white at root level (after paper, before closing)
    const whiteRegex = /,\n  white:\s*\{([\s\S]*?)\n  \},/;

    const patterns = {
      accent: accentRegex,
      warm: warmRegex,
      white: whiteRegex
    };

    Object.entries(patterns).forEach(([category, regex]) => {
      const match = alphaBlock.match(regex);
      if (match) {
        tokens.ALPHA[category] = {};
        const props = match[1].matchAll(/(\d+):\s*['"]([^'"]+)['"]/g);
        for (const [, key, value] of props) {
          tokens.ALPHA[category][key] = value;
        }
      }
    });
  }

  // Extract TYPOGRAPHY fontFamily
  const typoMatch = content.match(/fontFamily:\s*\{([^}]+)\}/s);
  if (typoMatch) {
    const fontMatch = typoMatch[1].matchAll(/(\w+):\s*\[([^\]]+)\]/g);
    for (const [, key, value] of fontMatch) {
      const fonts = value.match(/['"]([^'"]+)['"]/g).map(f => f.replace(/['"]/g, ''));
      tokens.TYPOGRAPHY.fontFamily[key] = fonts;
    }
  }

  // Extract SIZES
  const sizesMatch = content.match(/export const SIZES = \{([\s\S]*?)\} as const;/);
  if (sizesMatch) {
    const propsMatch = sizesMatch[1].matchAll(/(\w+):\s*(\d+)/g);
    for (const [, key, value] of propsMatch) {
      tokens.SIZES[key] = parseInt(value);
    }
  }

  // Extract LAYOUT.container.padding
  const layoutMatch = content.match(/container:\s*\{([^}]+)\}/s);
  if (layoutMatch) {
    const paddingMatch = layoutMatch[1].match(/padding:\s*['"]([^'"]+)['"]/);
    if (paddingMatch) {
      tokens.LAYOUT.container.padding = paddingMatch[1];
    }
  }

  // Note: SEMANTIC_TOKENS are manually defined in the CSS generation
  // to avoid complex parsing of token references

  return tokens;
}

const tokensContent = fs.readFileSync(tokensSourcePath, 'utf8');
const { COLORS, ALPHA, TYPOGRAPHY, SIZES, LAYOUT } = parseTokens(tokensContent);

/**
 * Generate CSS custom properties from design tokens
 */
function generateCSSVariables() {
  const css = `/**
 * AUTO-GENERATED DESIGN TOKENS
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 *
 * This file is automatically generated from src/design/tokens.ts
 * To update design tokens:
 *   1. Edit src/design/tokens.ts
 *   2. Run: npm run build:tokens
 *   3. The changes will be automatically reflected here
 *
 * Generated: ${new Date().toISOString()}
 */

:root {
  /* ========================================
     COLORS - Design Token Colors
     ======================================== */

  /* Ink (Text Colors) */
  --color-ink: ${COLORS.ink.DEFAULT};
  --color-ink-black: ${COLORS.ink.black};
  --color-ink-secondary: ${COLORS.ink.secondary};
  --color-ink-muted: ${COLORS.ink.muted};

  /* Paper (Background Colors) */
  --color-paper: ${COLORS.paper.DEFAULT};
  --color-paper-white: ${COLORS.paper.white};

  /* Accent (Brand Colors) */
  --color-accent: ${COLORS.accent.DEFAULT};
  --color-accent-hover: ${COLORS.accent.hover};
  --color-accent-light: ${COLORS.accent.light};

  /* Warm (Decorative) */
  --color-warm: ${COLORS.warm.DEFAULT};

  /* Hairline (Borders) */
  --color-hairline: ${COLORS.hairline.DEFAULT};

  /* ========================================
     ALPHA (TRANSPARENCY) VARIANTS
     ======================================== */

  /* Accent Alpha Variants */
  ${Object.entries(ALPHA.accent || {}).map(([key, value]) => `--alpha-accent-${key}: ${value};`).join('\n  ')}

  /* Warm Alpha Variants */
  ${Object.entries(ALPHA.warm || {}).map(([key, value]) => `--alpha-warm-${key}: ${value};`).join('\n  ')}

  /* Paper Alpha Variants */
  ${(() => {
    const vars = [];
    if (ALPHA.paper) {
      Object.entries(ALPHA.paper).forEach(([subKey, subObj]) => {
        if (typeof subObj === 'object') {
          Object.entries(subObj).forEach(([key, value]) => {
            vars.push(`--alpha-paper-${subKey}-${key}: ${value};`);
          });
        } else {
          vars.push(`--alpha-paper-${subKey}: ${subObj};`);
        }
      });
    }
    return vars.join('\n  ');
  })()}

  /* White Alpha Variants */
  ${Object.entries(ALPHA.white || {}).map(([key, value]) => `--alpha-white-${key}: ${value};`).join('\n  ')}

  /* ========================================
     SEMANTIC TOKENS (2025 Best Practice)
     Component-level tokens for easier theming
     ======================================== */

  /* Text Semantic Tokens */
  --text-primary: var(--color-ink);
  --text-secondary: var(--color-ink-secondary);
  --text-muted: var(--color-ink-muted);
  --text-inverse: var(--color-paper-white);
  --text-accent: var(--color-accent);

  /* Background Semantic Tokens */
  --bg-primary: var(--color-paper);
  --bg-secondary: var(--color-paper-white);
  --bg-accent: var(--color-accent);
  --bg-inverse: var(--color-ink);

  /* Button Primary Tokens */
  --button-primary-bg: var(--color-accent);
  --button-primary-bg-hover: var(--color-accent-hover);
  --button-primary-bg-active: var(--color-accent-hover);
  --button-primary-bg-disabled: var(--alpha-accent-50);
  --button-primary-text: var(--color-paper-white);
  --button-primary-text-disabled: var(--alpha-paper-white-60);
  --button-primary-border: transparent;
  --button-primary-shadow: var(--alpha-accent-30);
  --button-primary-shadow-hover: var(--alpha-accent-30);

  /* Button Secondary Tokens */
  --button-secondary-bg: transparent;
  --button-secondary-bg-hover: var(--alpha-warm-8);
  --button-secondary-bg-active: var(--alpha-warm-20);
  --button-secondary-bg-disabled: transparent;
  --button-secondary-text: var(--color-ink-secondary);
  --button-secondary-text-disabled: var(--color-ink-muted);
  --button-secondary-border: var(--color-hairline);
  --button-secondary-border-hover: var(--color-accent);
  --button-secondary-shadow: none;

  /* Card Tokens */
  --card-bg: var(--alpha-white-60);
  --card-bg-hover: var(--alpha-white-80);
  --card-border: var(--alpha-warm-20);
  --card-border-hover: var(--color-accent);
  --card-border-accent: var(--color-accent);
  --card-shadow: var(--alpha-accent-8);
  --card-shadow-hover: var(--alpha-accent-30);
  --card-text: var(--color-ink);
  --card-text-secondary: var(--color-ink-secondary);

  /* Input Tokens */
  --input-bg: var(--alpha-white-80);
  --input-bg-focus: var(--alpha-white-100);
  --input-bg-disabled: var(--alpha-warm-8);
  --input-border: var(--alpha-warm-30);
  --input-border-hover: var(--alpha-warm-30);
  --input-border-focus: var(--color-accent);
  --input-border-error: #DC2626;
  --input-text: var(--color-ink);
  --input-text-placeholder: var(--color-ink-muted);
  --input-text-disabled: var(--color-ink-muted);
  --input-shadow: none;
  --input-shadow-focus: var(--alpha-accent-10);

  /* Header Tokens */
  --header-bg: var(--color-accent);
  --header-bg-blur: var(--alpha-accent-95);
  --header-text: var(--color-paper-white);
  --header-text-hover: var(--color-paper-white);
  --header-text-active: var(--color-paper-white);
  --header-border: var(--alpha-accent-14);
  --header-shadow: none;

  /* Link Tokens */
  --link-text: var(--color-accent-light);
  --link-text-hover: var(--color-accent);
  --link-text-visited: var(--color-accent);
  --link-text-active: var(--color-accent-hover);
  --link-underline: none;
  --link-underline-hover: none;

  /* Overlay/Modal Tokens */
  --overlay-bg: var(--alpha-accent-60);
  --overlay-backdrop: blur(20px);

  /* Focus Ring Tokens (Accessibility) */
  --focus-ring: var(--color-accent);
  --focus-ring-width: 2px;
  --focus-ring-offset: 2px;
  --focus-ring-style: solid;

  /* Legacy Aliases (for backward compatibility) */
  --accent-primary: var(--color-accent);
  --accent-secondary: var(--color-accent-light);

  /* ========================================
     TYPOGRAPHY
     ======================================== */

  --font-serif: ${TYPOGRAPHY.fontFamily.serif.join(', ')};
  --font-sans: ${TYPOGRAPHY.fontFamily.sans.join(', ')};

  /* ========================================
     SPACING
     ======================================== */

  --space-xs: 0.5rem;
  --space-sm: 1rem;
  --space-md: 2rem;
  --space-lg: 4rem;
  --space-xl: 6rem;

  /* ========================================
     LAYOUT
     ======================================== */

  --max-width: 1200px;
  --container-padding: ${LAYOUT.container.padding};

  /* ========================================
     HEADER
     ======================================== */

  --header-height: ${SIZES.HEADER_HEIGHT}px;
  --header-offset: clamp(100px, 14vh, 140px);
  --header-offset-mobile: 110px;

  /* ========================================
     BREAKPOINTS
     ======================================== */

  --breakpoint-small: 390px;
  --breakpoint-mobile: 640px;
  --breakpoint-tablet: 768px;
  --breakpoint-desktop: 1024px;
  --breakpoint-wide: 1280px;

  /* ========================================
     TOUCH TARGETS (Apple HIG)
     ======================================== */

  --touch-target-min: 44px;

  /* ========================================
     CONTAINER QUERY BREAKPOINTS
     ======================================== */

  --container-sm: 280px;
  --container-md: 400px;
  --container-lg: 600px;
}
`;

  return css;
}

// Generate and write CSS
try {
  const css = generateCSSVariables();
  fs.writeFileSync(outputPath, css, 'utf8');
  console.log('✅ Design tokens generated successfully!');
  console.log(`   Output: ${path.relative(process.cwd(), outputPath)}`);
  console.log('   Single source of truth: src/design/tokens.ts');
} catch (error) {
  console.error('❌ Error generating tokens:', error.message);
  process.exit(1);
}
