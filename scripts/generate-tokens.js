#!/usr/bin/env node
/**
 * Design Token Generator
 *
 * Automatically generates CSS custom properties from TypeScript design tokens.
 * This ensures a single source of truth and prevents drift between TS and CSS.
 *
 * Best Practices (2025):
 * - Single source of truth (tokens.ts)
 * - Automated CSS generation (this script)
 * - Type safety via TypeScript
 * - No manual CSS duplication
 *
 * Usage: node scripts/generate-tokens.js
 */

const fs = require('fs');
const path = require('path');

const tokensSourcePath = path.join(__dirname, '../src/design/tokens.ts');
const outputPath = path.join(__dirname, '../src/css/_tokens.css');

// Check if source tokens exist
if (!fs.existsSync(tokensSourcePath)) {
  console.error('❌ Error: Design tokens not found at src/design/tokens.ts');
  process.exit(1);
}

/**
 * Parse TypeScript tokens file to extract color values
 * This approach doesn't require TypeScript compilation
 */
function parseTokens(content) {
  const tokens = {
    COLORS: {},
    ALPHA: {},
    TYPOGRAPHY: { fontFamily: {} },
    SIZES: {},
    LAYOUT: { container: {} }
  };

  // Extract COLORS
  const colorsMatch = content.match(/export const COLORS = \{([\s\S]*?)\} as const;/);
  if (colorsMatch) {
    const colorsBlock = colorsMatch[1];

    // Parse each color category
    const categories = ['ink', 'paper', 'accent', 'warm', 'hairline'];
    categories.forEach(category => {
      const regex = new RegExp(`${category}:\\s*\\{([^}]+)\\}`, 's');
      const match = colorsBlock.match(regex);
      if (match) {
        tokens.COLORS[category] = {};
        const props = match[1].matchAll(/(\w+):\s*['"]([^'"]+)['"]/g);
        for (const [, key, value] of props) {
          tokens.COLORS[category][key] = value;
        }
      }
    });
  }

  // Extract ALPHA (transparency variants)
  const alphaMatch = content.match(/export const ALPHA = \{([\s\S]*?)\} as const;/);
  if (alphaMatch) {
    const alphaBlock = alphaMatch[1];

    // Parse each alpha category
    const alphaCategories = ['accent', 'warm', 'paper', 'white'];
    alphaCategories.forEach(category => {
      const regex = new RegExp(`${category}:\\s*\\{([^}]+)\\}`, 's');
      const match = alphaBlock.match(regex);
      if (match) {
        tokens.ALPHA[category] = {};
        const props = match[1].matchAll(/(\w+|\d+):\s*['"]([^'"]+)['"]/g);
        for (const [, key, value] of props) {
          tokens.ALPHA[category][key] = value;
        }
      }
    });
  }

  // Extract TYPOGRAPHY fontFamily
  const typoMatch = content.match(/fontFamily:\s*\{([^}]+)\}/s);
  if (typoMatch) {
    const fontMatch = typoMatch[1].matchAll(/(\w+):\s*\[([^\]]+)\]/g);
    for (const [, key, value] of fontMatch) {
      const fonts = value.match(/['"]([^'"]+)['"]/g).map(f => f.replace(/['"]/g, ''));
      tokens.TYPOGRAPHY.fontFamily[key] = fonts;
    }
  }

  // Extract SIZES
  const sizesMatch = content.match(/export const SIZES = \{([\s\S]*?)\} as const;/);
  if (sizesMatch) {
    const propsMatch = sizesMatch[1].matchAll(/(\w+):\s*(\d+)/g);
    for (const [, key, value] of propsMatch) {
      tokens.SIZES[key] = parseInt(value);
    }
  }

  // Extract LAYOUT.container.padding
  const layoutMatch = content.match(/container:\s*\{([^}]+)\}/s);
  if (layoutMatch) {
    const paddingMatch = layoutMatch[1].match(/padding:\s*['"]([^'"]+)['"]/);
    if (paddingMatch) {
      tokens.LAYOUT.container.padding = paddingMatch[1];
    }
  }

  return tokens;
}

const tokensContent = fs.readFileSync(tokensSourcePath, 'utf8');
const { COLORS, ALPHA, TYPOGRAPHY, SIZES, LAYOUT } = parseTokens(tokensContent);

/**
 * Generate CSS custom properties from design tokens
 */
function generateCSSVariables() {
  const css = `/**
 * AUTO-GENERATED DESIGN TOKENS
 *
 * ⚠️  DO NOT EDIT THIS FILE MANUALLY
 *
 * This file is automatically generated from src/design/tokens.ts
 * To update design tokens:
 *   1. Edit src/design/tokens.ts
 *   2. Run: npm run build:tokens
 *   3. The changes will be automatically reflected here
 *
 * Generated: ${new Date().toISOString()}
 */

:root {
  /* ========================================
     COLORS - Design Token Colors
     ======================================== */

  /* Ink (Text Colors) */
  --color-ink: ${COLORS.ink.DEFAULT};
  --color-ink-black: ${COLORS.ink.black};
  --color-ink-secondary: ${COLORS.ink.secondary};
  --color-ink-muted: ${COLORS.ink.muted};

  /* Paper (Background Colors) */
  --color-paper: ${COLORS.paper.DEFAULT};
  --color-paper-white: ${COLORS.paper.white};

  /* Accent (Brand Colors) */
  --color-accent: ${COLORS.accent.DEFAULT};
  --color-accent-hover: ${COLORS.accent.hover};
  --color-accent-light: ${COLORS.accent.light};

  /* Warm (Decorative) */
  --color-warm: ${COLORS.warm.DEFAULT};

  /* Hairline (Borders) */
  --color-hairline: ${COLORS.hairline.DEFAULT};

  /* ========================================
     ALPHA (TRANSPARENCY) VARIANTS
     ======================================== */

  /* Accent Alpha Variants */
  ${Object.entries(ALPHA.accent || {}).map(([key, value]) => `--alpha-accent-${key}: ${value};`).join('\n  ')}

  /* Warm Alpha Variants */
  ${Object.entries(ALPHA.warm || {}).map(([key, value]) => `--alpha-warm-${key}: ${value};`).join('\n  ')}

  /* Paper Alpha Variants */
  ${Object.entries(ALPHA.paper || {}).map(([key, value]) => `--alpha-paper-${key}: ${value};`).join('\n  ')}

  /* White Alpha Variants */
  ${Object.entries(ALPHA.white || {}).map(([key, value]) => `--alpha-white-${key}: ${value};`).join('\n  ')}

  /* ========================================
     SEMANTIC COLORS
     ======================================== */

  --bg-primary: var(--color-paper);
  --text-primary: var(--color-ink);
  --text-secondary: var(--color-ink-secondary);
  --text-muted: var(--color-ink-muted);
  --accent-primary: var(--color-accent);
  --accent-secondary: var(--color-accent-light);

  /* ========================================
     TYPOGRAPHY
     ======================================== */

  --font-serif: ${TYPOGRAPHY.fontFamily.serif.join(', ')};
  --font-sans: ${TYPOGRAPHY.fontFamily.sans.join(', ')};

  /* ========================================
     SPACING
     ======================================== */

  --space-xs: 0.5rem;
  --space-sm: 1rem;
  --space-md: 2rem;
  --space-lg: 4rem;
  --space-xl: 6rem;

  /* ========================================
     LAYOUT
     ======================================== */

  --max-width: 1200px;
  --container-padding: ${LAYOUT.container.padding};

  /* ========================================
     HEADER
     ======================================== */

  --header-height: ${SIZES.HEADER_HEIGHT}px;
  --header-offset: clamp(100px, 14vh, 140px);
  --header-offset-mobile: 110px;

  /* ========================================
     BREAKPOINTS
     ======================================== */

  --breakpoint-small: 390px;
  --breakpoint-mobile: 640px;
  --breakpoint-tablet: 768px;
  --breakpoint-desktop: 1024px;
  --breakpoint-wide: 1280px;

  /* ========================================
     TOUCH TARGETS (Apple HIG)
     ======================================== */

  --touch-target-min: 44px;

  /* ========================================
     CONTAINER QUERY BREAKPOINTS
     ======================================== */

  --container-sm: 280px;
  --container-md: 400px;
  --container-lg: 600px;
}
`;

  return css;
}

// Generate and write CSS
try {
  const css = generateCSSVariables();
  fs.writeFileSync(outputPath, css, 'utf8');
  console.log('✅ Design tokens generated successfully!');
  console.log(`   Output: ${path.relative(process.cwd(), outputPath)}`);
  console.log('   Single source of truth: src/design/tokens.ts');
} catch (error) {
  console.error('❌ Error generating tokens:', error.message);
  process.exit(1);
}
